Name: Rebecca Lassman
Compile:
Run:
Known bugs/limitations: none
Discussion: A9 was slightly slower than A5. The real time for A5 was 0m0.374s, while A9’s real time was 0m0.547s. That is only a 0.173 millisecond difference. Similarly, the user time for A5 was 0m1.253s and for A9 was 0m1.754s. The reason A5 is slightly more efficient is because of the A9’s implementation of adding the latitude and longitude data from ziplocs. For each ziplocs entry, there are two searches because the updateKey() method used to replace a Place with a LocatedPlace must find the correct node to replace its element. The two searches for each element in ziplocs both have a worst-case complexity of O(klogn) where k is the size of ziplocs and n is the size of the tree. In A5, there is only one search for each element in ziplocs, which also has a worst-case complexity of O(klogn). This is because once the index in an ArrayList is found, there is no need to find it again. A5 also has an additional O(n) loop, but O(klogn) + O(n) is less than 2*O(klogn), which accounts for A9’s slightly slower runtime. A9’s implementation could be changed to be the same as A5, but the tree would have to be implemented non-generically so that once a Node is located, the latitude and longitude can be changed from the LinkedBinaryTree or AVLTree class. This would probably make A9 more efficient, but then the tree classes would only be able to be used to store place objects, so making this change would depend on whether efficiency or versatility is more important. 
