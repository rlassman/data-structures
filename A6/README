Name: Rebecca Lassman
How to compile:
How to run:
Known bugs/limitations: none
Discussion: The remove method first uses the contains method to check if the element is in the tree so that if it is not, it will return false. If the element is in the tree, it calls the recursive remove method to find and remove the element. The method first searches for the element by comparing the current root node’s element to the element it is trying to remove. If the resulting int is negative then the element is in the left subtree, so the method is called recursively with the left child as the new root. Root’s left child node is set to this recursive call so that it will contain the correct node once the element is found. The same is done to the right child if the comparison yields a positive int. Once the element is found, there are two possibilities. If the root node containing the element has zero or one child, its parent’s right or left child node is set to root’s one child (or null if it has no children). Otherwise, the method minKey is called to find the leftmost element in root’s right subtree. It then replaces root’s element with minKey and sets root’s right child to the recursive call of the remove method on the right subtree to remove the old minKey node. Once all the recursive calls are complete, the non-recursive remove method checks again if the element is in the tree, and if it is, sets the root to the node returned by the call to the recursive remove. This is because in the case where the root is removed and only had one child, that child must become the new root of the tree. Size is decreased by one and the method returns true. 
Extra Credit: I implemented the first extra credit, in which files from the same date average the polling percentage. It still expects the data files to be given in increasing date order. 
